import { Beacon } from "./Beacon";
export type SelfHandler = () => void;
export type PeerHandler = (peerId: string) => void;
export type PeerStreamHandler = (peerId: string, stream: MediaStream) => void;
export type ActionSender<T> = (data: T, ...peers: Array<string>) => void;
export type ActionReceiver<T> = (data: T, peerId: string) => void;
export type ActionReceiverSetter<T> = (handler: ActionReceiver<T>) => void;
export type ActionDuplex<T> = [ActionSender<T>, ActionReceiverSetter<T>];
export declare class Bridge<T = undefined> {
    private beacon;
    private _ready;
    private _you?;
    private _room?;
    private _data?;
    private _stream?;
    private _peers;
    private _actions;
    private _onJoin;
    private _onLeave;
    private _onPeerStream;
    private _onPeerJoin;
    private _onPeerLeave;
    constructor(beacon: Beacon<T>);
    get ready(): Promise<void>;
    get you(): string | undefined;
    get room(): string | undefined;
    get data(): T | undefined;
    static withBeacon<T>(url: string): Bridge<T>;
    private addPeer;
    private handleSignal;
    private handleData;
    private sendData;
    create(data: T, stream?: MediaStream): Promise<import("./response").CreatedData>;
    getInfo(room: string): Promise<import("./response").InfoData<T>>;
    join(room: string, stream?: MediaStream): Promise<import("./response").JoinedData<T>>;
    leave(): void;
    onJoin(handler: SelfHandler): void;
    onLeave(handler: SelfHandler): void;
    onPeerStream(handler: PeerStreamHandler): void;
    onPeerJoin(handler: PeerHandler): void;
    onPeerLeave(handler: PeerHandler): void;
    makeAction<T>(name: string): ActionDuplex<T>;
}
